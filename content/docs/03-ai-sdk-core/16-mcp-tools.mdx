---
title: Model Context Protocol (MCP) Tools
description: Learn how to connect to Model Context Protocol (MCP) servers and use their tools with AI SDK Core.
---

# Model Context Protocol (MCP) Tools

<Note type="warning">
  The MCP tools feature is experimental and may change in the future.
</Note>

The AI SDK supports connecting to [Model Context Protocol (MCP)](https://modelcontextprotocol.io/) servers to access their tools.
This enables your AI applications to discover and use tools across various services through a standardized interface.

## Initializing an MCP Client

We recommend using HTTP transport (like `StreamableHTTPClientTransport`) for production deployments. The stdio transport should only be used for connecting to local servers as it cannot be deployed to production environments.

Create an MCP client using one of the following transport options:

- **HTTP transport (Recommended)**: Use transports from MCP's official TypeScript SDK like `StreamableHTTPClientTransport` for production deployments
- SSE (Server-Sent Events): An alternative HTTP-based transport
- `stdio`: For local development only. Uses standard input/output streams for local MCP servers

### HTTP Transport (Recommended)

For production deployments, we recommend using HTTP transports like `StreamableHTTPClientTransport` from MCP's official TypeScript SDK:

```typescript
import { experimental_createMCPClient as createMCPClient } from 'ai';
import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';

const url = new URL('https://your-server.com/mcp');
const mcpClient = await createMCPClient({
  transport: new StreamableHTTPClientTransport(url, {
    sessionId: 'session_123',
  }),
});
```

### SSE Transport

SSE provides an alternative HTTP-based transport option. Configure it with a `type` and `url` property:

```typescript
import { experimental_createMCPClient as createMCPClient } from 'ai';

const mcpClient = await createMCPClient({
  transport: {
    type: 'sse',
    url: 'https://my-server.com/sse',

    // optional: configure HTTP headers, e.g. for authentication
    headers: {
      Authorization: 'Bearer my-api-key',
    },
  },
});
```

### Stdio Transport (Local Servers)

<Note type="warning">
  The stdio transport should only be used for local servers.
</Note>

The Stdio transport can be imported from either the MCP SDK or the AI SDK:

```typescript
import { experimental_createMCPClient as createMCPClient } from 'ai';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
// Or use the AI SDK's stdio transport:
// import { Experimental_StdioMCPTransport as StdioClientTransport } from 'ai/mcp-stdio';

const mcpClient = await createMCPClient({
  transport: new StdioClientTransport({
    command: 'node',
    args: ['src/stdio/dist/server.js'],
  }),
});
```

### Custom Transport

You can also bring your own transport by implementing the `MCPTransport` interface for specific requirements not covered by the standard transports.

<Note>
  The client returned by the `experimental_createMCPClient` function is a
  lightweight client intended for use in tool conversion. It currently does not
  support all features of the full MCP client, such as: authorization, session
  management, resumable streams, and receiving notifications.
</Note>

### Closing the MCP Client

After initialization, you should close the MCP client based on your usage pattern:

- For short-lived usage (e.g., single requests), close the client when the response is finished
- For long-running clients (e.g., command line apps), keep the client open but ensure it's closed when the application terminates

When streaming responses, you can close the client when the LLM response has finished. For example, when using `streamText`, you should use the `onFinish` callback:

```typescript
const mcpClient = await experimental_createMCPClient({
  // ...
});

const tools = await mcpClient.tools();

const result = await streamText({
  model: 'openai/gpt-4.1',
  tools,
  prompt: 'What is the weather in Brooklyn, New York?',
  onFinish: async () => {
    await mcpClient.close();
  },
});
```

When generating responses without streaming, you can use try/finally or cleanup functions in your framework:

```typescript
let mcpClient: MCPClient | undefined;

try {
  mcpClient = await experimental_createMCPClient({
    // ...
  });
} finally {
  await mcpClient?.close();
}
```

## Using MCP Tools

The client's `tools` method acts as an adapter between MCP tools and AI SDK tools. It supports two approaches for working with tool schemas:

### Schema Discovery

With schema discovery, all tools offered by the server are automatically listed, and input parameter types are inferred based on the schemas provided by the server:

```typescript
const tools = await mcpClient.tools();
```

This approach is simpler to implement and automatically stays in sync with server changes. However, you won't have TypeScript type safety during development, and all tools from the server will be loaded

### Schema Definition

For better type safety and control, you can define the tools and their input schemas explicitly in your client code:

```typescript
import { z } from 'zod';

const tools = await mcpClient.tools({
  schemas: {
    'get-data': {
      inputSchema: z.object({
        query: z.string().describe('The data query'),
        format: z.enum(['json', 'text']).optional(),
      }),
    },
    // For tools with zero inputs, you should use an empty object:
    'tool-with-no-args': {
      inputSchema: z.object({}),
    },
  },
});
```

This approach provides full TypeScript type safety and IDE autocompletion, letting you catch parameter mismatches during development. When you define `schemas`, the client only pulls the explicitly defined tools, keeping your application focused on the tools it needs

## Using MCP Resources

MCP servers can expose resources, which are structured information sources (like files, APIs, or databases) that AI applications can retrieve and provide to models as context. The MCP client provides methods to discover and read these resources.

### Listing Resources

Use `listResources()` to discover available resources:

```typescript
const result = await mcpClient.listResources();

for (const resource of result.resources) {
  console.log(`Resource: ${resource.name}`);
  console.log(`  URI: ${resource.uri}`);
  console.log(`  Description: ${resource.description}`);
  console.log(`  MIME Type: ${resource.mimeType}`);
}

// Handle pagination if needed
if (result.nextCursor) {
  const nextPage = await mcpClient.listResources({ cursor: result.nextCursor });
}
```

### Listing Resource Templates

Resource templates define URI patterns for dynamic resources. Use `listResourceTemplates()` to discover them:

```typescript
const result = await mcpClient.listResourceTemplates();

for (const template of result.resourceTemplates) {
  console.log(`Template: ${template.name}`);
  console.log(`  URI Template: ${template.uriTemplate}`);
  console.log(`  Description: ${template.description}`);
}
```

### Reading Resources

Use `readResource()` to fetch the content of a specific resource:

```typescript
// Using a string URI
const result = await mcpClient.readResource('file:///path/to/document.txt');

// Or using an object with uri property (matches reference SDK)
const result = await mcpClient.readResource({ uri: 'file:///path/to/document.txt' });

for (const content of result.contents) {
  if ('text' in content) {
    console.log('Text content:', content.text);
  } else if ('blob' in content) {
    console.log('Binary content (base64):', content.blob);
  }
}
```

### Including Resources as Tools

You can optionally include resources as callable tools by setting `includeResources: true`. This allows the AI model to automatically access resources when needed:

```typescript
import { experimental_createMCPClient as createMCPClient } from 'ai';
import { streamText } from 'ai';
import { openai } from '@ai-sdk/openai';

// Create MCP client
const mcpClient = await createMCPClient({
  transport: { type: 'sse', url: 'https://your-server.com/mcp' },
});

// Get tools with resources included
const tools = await mcpClient.tools({ includeResources: true });

// Use with streamText - AI can now call resource tools automatically
const result = streamText({
  model: openai('gpt-4'),
  tools, // Pass tools including resources
  maxSteps: 5,
  prompt: 'Read the latest data and summarize it',
  onFinish: async () => {
    await mcpClient.close();
  },
});

for await (const chunk of result.textStream) {
  process.stdout.write(chunk);
}
```

**How it works:**

Resources are exposed as tools with predictable names:
- Direct resources: `resource_${resourceName}`
- Resource templates: `resource_template_${templateName}`

When included as tools:
- Direct resources become zero-parameter tools that read the resource when called
- Resource templates become tools with parameters extracted from their URI template
- The AI model can call these tools just like any other tool
- Resource tools return `ReadResourceResult` containing the resource content

**Example with resource templates:**

```typescript
// If the MCP server exposes a resource template:
// URI: "docs://{section}/{page}"

const tools = await mcpClient.tools({ includeResources: true });

// The AI can now call: resource_template_docs
// With parameters: { section: "api", page: "authentication" }
const result = await generateText({
  model: openai('gpt-4'),
  tools,
  prompt: 'Read the authentication documentation and explain how OAuth works',
});
```

## Examples

You can see MCP tools in action in the following example:

<ExampleLinks
  examples={[
    {
      title: 'Learn to use MCP tools in Node.js',
      link: '/cookbook/node/mcp-tools',
    },
  ]}
/>
